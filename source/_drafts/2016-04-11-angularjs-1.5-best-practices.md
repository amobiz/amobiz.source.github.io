title: "AngularJS 1.5 最佳實務"
date: 2016-04-11 03:44:00
comments: true
category:
  - Programming
tags:
  - notes
  - AngularJS
---

## 前言

本文整理截至目前 AngularJS 1.5 為止， 個人以為的最佳實務做法。

為什麼現在？基於以下三點理由：

* 雖然 AngularJS 2.0 發佈在即 (據說即將於 5 月正式發佈)，但是既有的 AngularJS 1.x 程式碼仍需要維護。
* 由於 AngularJS 1.x 受到廣泛的歡迎，前後做了不少的改進，因此網路上到處可見其實已經過時的作法。
* 基於向後相容的原則，有些功能雖然被保留下來，但未必是最佳作法。

『你可以這麼做，不代表你必須這麼做』，基於『JavaScript: The Good Parts』的哲理，本文適合具有 AngularJS 1.x 實務開發經驗，然而卻隨著 AngularJS 的發展，逐漸對於網路上充斥各種主觀、矛盾的說法、用法感到困惑的開發者。

雖然遵循本文提出的原則，可以以趨近於元件化的風格開發 AngularJS 1.5 應用程式，但本文不涉及 AngularJS 1.x 移轉到 AngularJS 2.0 議題。

<!-- more -->

<style>
.hidden {
	display: none;
}
</style>

在閱讀本文之前，建議讀者可以先閱讀 [Angular 1 Style Guide](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md) 這篇文章，本文的程式碼基本上遵循該文倡導的風格，除了少數與下一篇參考文章的建議牴觸之外。

本文主要內容則是基於 [Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef)
 這篇文章。

### 不要使用 `ng-controller`

出處：[Don’t use ng-controller](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#0b67)

典型的 `ng-controller` 用法如下：

```html
<div ng-controller="myController">
  <strong>{{foo}}</strong>
</div>
```

這有什麼問題呢？

* `ng-controller` 違反元件封裝的原則：template 未能與 controller 程式碼封裝在一起，而獨自暴露在 html 中。
* 無法重複使用：基於第一個理由，你的 controller 無法直接重複使用：必須複製 template。

### 不要在路由中指定 controller

出處：[Don’t specify controllers in your routes](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#5b61)

不論是 AngularJS 內建的 router 或是一般常用的 ui-router，典型的寫法，都是同時指定 `template` / `templateUrl` 及 `controller`：

```js
$routeProvider.
  when('/phones', {
    templateUrl: 'partials/phone-list.html',
    controller: 'PhoneListController'
  });
```

這有什麼問題呢？

其實跟『不要使用 `ng-controller`』的狀況類似，都是與封裝有關：

* 若使用 `template` 來指定，那麼當要重複使用 controller 時，就必須複製該 template，
* 若使用 `templateUrl` 來指定，那麼就有可能不小心指定了錯誤的 template 檔案，造成與 controller 不一致的狀況。

### 使用 component 取代 `ng-controller`

出處：

* [Make everything a directive](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#e211)
* [Exploring the Angular 1.5 .component() method](https://toddmotto.com/exploring-the-angular-1-5-component-method)

基於上面兩點，應該將原本可能使用到 `ng-controller` 的部份，一律改用 component 來寫。

雖然還是可以使用 [`$compileProvider.directive()`](https://docs.angularjs.org/api/ng/provider/$compileProvider#directive) 來定義 directive，在 AngularJS 1.5 下，則提供了新的 [`.component()`](https://docs.angularjs.org/api/ng/provider/$compileProvider#component) 函數。這是為了讓 AngularJS 1.X 程式移植到 AngularJS 2.0 比較容易，而特地提供，讓開發者以比較接近 AngularJS 2.0 component 寫法的方式來定義元件：

__myComponent.html__
```html
<strong>{{vm.foo}}</strong>
```

__myComponent.js__
```js
var myTemplate = require('./myComponent.html');

var myComponent = {
	bindings: {
		foo: '=',
		value: '@',
		oneWay: '<',
		twoWay: '=',
		callback: '&'
	},
	template: myTemplate,
	controller: MyComponentController,
	controllerAs: 'vm'
};

myapp.component('myComponent', myComponent);

MyComponentController.$inject = ['$http'];
function MyComponentController($http) {
	this.foo = 'bar';
}
```

注意，使用 `.component()` 函數來建立元件時：

* 必然以 `restrict: 'E'` 的形式建立，也就是只能建立 tag 形式的元件，
* 必然以 `scope: {}` 的形式建立，也就是建立 "isolated scope"，不會繼承 parent scope。因此，若需要外部 scope 的資料，必須明確在 `bindings` 中定義屬性，並在使用 tag 時傳入。
* 承上，在 `.component()` 函數中，已使用 `bindings` 取代 `scope` 及在 1.3 ~ 1.4 之間引入的 `bindToController` 屬性。所以在 `.component()` 函數中，`scope` 及 `bindToController` 屬性無效，也不應再使用。
* 如果你沒有自行指定 `controllerAs`，則會自動幫你指定為 `$ctrl`，也就是說，強迫必須使用 `controllerAs` 語法 (參考後面『永遠使用 "controllerAs" 語法』)。

另外，

* 由於 `.component()` 函數只能用來建立 tag 元件，如果元件必須同時或者只支援其他類型，譬如 attribute 形式，則必須使用 `.directive()` 函數定義 (參考下面 Directive Factory 的說明)。
* 上面使用 `require()` 引入 template 檔案的作法，是採用 Webpack 的作法。實務上可以直接使用 `templateUrl` 指定外部檔案, 或直接以內聯的形式定義 `template` 內容。
* 推薦像上面這樣，將 `myComponent` 的設定獨立定義，甚至獨立為一個檔案，這樣將來要移轉為 AngularJS 2.0 元件會比較方便。
* 將 controller 放在後面獨立定義，並以 constructor 的形式，開頭名稱大寫，是 John Papa [推薦的作法](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#named-vs-anonymous-functions)。

最後，再提醒一下，定義元件時，使用 `myComponent` 名稱，這名稱就稱為該元件的 "directive name"。首字小寫，這是 AngularJS 定義元件的推薦慣例。(當作是定義 instance 變數，所以小寫開頭。)
而在 html 中使用時，則必須使用 `my-component`，這稱為該元件的 "tag name"。全部小寫，以 `-` 分隔單字，雖然 HTML 不區分大小寫，但是使用全小寫是推薦的慣例。
而 controller 的名稱為 `MyComponent`，因為它是一個 constructor。首字大寫，表示這是一個 class，這是 JavaScript 的慣例。

一旦定義好 component，就可以如下使用：

__在 markup 中使用__

```html
<body ng-app="myApp">
	<my-component foo="bar"></my-component>
</body>
```

__在路由中使用__

```js
$routeProvider.
  when('/phones', {
    template: '<my-component foo="bar"></my-component>'
  });
```

好處如下：

* 完全封裝，不須再擔心 controller 與 template 不一致，
* 需要的屬性可以由外部以偏好的方式，以 expression 的形式指定，傳入的是計算後的值，元件內部不再依賴於外部的特定屬性名稱，
* 如果需要處理事件，也可以在 `bindings` 中以 `eventName: '&'` 的方式定義，同樣由外部以偏好的方式指定，元件不需要依賴於外部 scope 的特定方法名稱，
* 因為是 "isolated scope"，所以不必擔心 scope 之間的資料存取、覆蓋、同步問題。

[Refactoring Angular Apps to Component Style](http://teropa.info/blog/2015/10/18/refactoring-angular-apps-to-components.html) 這篇文章詳細介紹各種將 controller 改用 component 的形式撰寫的步驟，相當值得一讀，強烈推薦。

### 使用 `.component()` 定義 tag 元件；使用 `.directive()` 定義 attribute directive

建議只要是 tag 形式的 directive，都使用 `.component()` 函數來建立。其它情況則使用 `.directive()` 函數。這裡一併列出建議的 tag 元件 及 attribute directive 的參考寫法，做為對照。

1. 定義 component / tag directive：

	```js
	var myTemplate = '<div></div>';
	var myComponent = {
		bindings: {
			value: '@',
			oneWay: '<',
			twoWay: '=',
			callback: '&'
		},
		template: myTemplate,
		controller: MyComponentController,
		controllerAs: 'vm'
	};

	app.component('myComponent', myComponent);

	MyComponentController.$inject = ['$http'];
	function MyComponentController($http) {
	}
	```

2. 定義 attribute directive：

	```js
	var myDirective = {
		restrict: 'A',
		scope: {
			value: '@',
			oneWay: '<',
			twoWay: '=',
			callback: '&'
		},
		link: myDirectiveLinker
	};

	app.directive('myDirective', myDirective);

	function myDirectiveLinker(scope, element, attrs) {
	}
	```

### 永遠使用 isolated scope

出處：[Always use an isolated scope](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#f77d)

首先，你只有在定義 directive 時，才能指定 scope 種類 (註)。而 scope 有三種：

1. isolated scope: `scope: {}`

	建立一個獨立的 scope。要交換的資料必須明確定義。

2. new scope: `scope: true`

	建立新的 child scope，並且繼承父 scope。

3. no scope: `scope: false`

	不建立 scope，直接使用父 scope。

這有什麼問題呢？

* 既然 directive 就是 tag 和 attribute (還有 class 和 comment 但是官方不建議使用)，讓它們可以直接存取父元件的資料不是很奇怪嗎？標準 html 的標籤不都是要自行指定屬性？

* 繼承了父 scope，也就意謂著依賴於父 scope，因此元件的可重用性就大幅降低。

因此，強烈建議一律使用 "isolated scope"，不要使用另外兩種。當需要外部 scope 資料時，請明確定義屬性，並由外部指定傳入。

註：即使在 `ng-controller` 中使用 "controllerAs" 語法，也只是幫你以指定的名稱建立一個包裹物件而已，scope 類型仍然是 "new scope"，並無法指定 scope 類型。這也是一個不應該使用 `ng-controller` 的好理由。

### 永遠將要傳遞的資料以物件加以包裹，或使用 "controllerAs" 語法

出處：

* [Only ever bind to sub-properties of an object](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#838c)
* [Exploring Angular 1.3: Binding to Directive Controllers](http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html)

只要遵循上面『使用 component 取代 `ng-controller`』的原則，即自動 (強制) 獲得使用 "controllerAs" 及 "isolated scope" 的好處。

如果你不需要知道 AngularJS 過去最被詬病的 scope 黑暗歷史，或者，你已經了解什麼是 "controllerAs"，可以放心跳過這一段。

像這樣的寫法：

```html
<input type="text" ng-model="username" />
```

其中 `username` 將直接繫結到上層 scope 的 `username` 屬性。這裡的關鍵字是『上層 scope』。

這有什麼問題呢？

* 由於某些 AngularJS 的 directive，譬如 `ngIf`，會建立新的 scope，也就是前面的提到的 "new scope"，注意 "new scope" 會繼承到 parent scope。意思是說，你的 binding 將會根據你的 tag 所在的位置，因而繼承了你沒有預料到的『上層 scope』，因此而可能有不同的行為。

* 其次，由於屬性是以 prototype 的方式繼承，一旦 child scope 建立了同名的屬性，就同時遮蔽了 parent scope 的同名屬性。使得原本希望直接更新 parent scope 屬性的意圖落空。

注意，以下範例為了清楚起見，直接使用 `ng-controller` 建立新的 scope，實務上仍然建議『使用 component 取代 `ng-controller`』。

<p data-height="268" data-theme-id="0" data-slug-hash="NNywWd" data-default-tab="result" data-user="amobiz" class="codepen">See the Pen <a href="http://codepen.io/amobiz/pen/NNywWd/">AngularJS Scope Problem</a> by amobiz (<a href="http://codepen.io/amobiz">@amobiz</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

{% element class:hidden %}
```html
<div ng-app="app">
	<h4>Form 1</h4>
	<form ng-controller="ParentController">
		<label>Username: </label>{{username}}<br>
		<input type="text" ng-model="username" />
	</form>

	<h4>Form 2</h4>
	<form ng-controller="ParentController">
		<label>Username: </label>{{username}}<br>
		<div ng-if="!registered">
			<input type="text" ng-model="username" />
		</div>
	</form>
</div>
```

```js
angular.module('app', [])
.controller('ParentController', ParentController)

function ParentController($scope) {
	$scope.username = 'My Name';
}
```
{% endelement %}

注意上面 Form 2，當你輸入資料時，ParentController 的 `username` 並不會同步更新。

為了避開巢狀 scope 的 prototype properties 繼承問題，可以在 parent scope 中以物件的形式將值包裝起來。
這樣，在 child scope 中，只要永遠不直接對 scope 設定屬性，就不用擔心 scope 屬性遮蔽問題。而透過該物件存取其屬性，就能自由與 parent scope 交換存取資料。

<p data-height="268" data-theme-id="0" data-slug-hash="oxEowv" data-default-tab="result" data-user="amobiz" class="codepen">See the Pen <a href="http://codepen.io/amobiz/pen/oxEowv/">AngularJS Scope via Object</a> by amobiz (<a href="http://codepen.io/amobiz">@amobiz</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

{% element class:hidden %}
```html
<div ng-app="app">
	<h4>Form 1</h4>
	<form ng-controller="ParentController">
		<label>Username: </label>{{vm.username}}<br>
		<input type="text" ng-model="vm.username" />
	</form>

	<h4>Form 2</h4>
	<form ng-controller="ParentController">
		<label>Username: </label>{{vm.username}}<br>
		<div ng-if="!vm.registered">
			<input type="text" ng-model="vm.username" />
		</div>
	</form>
</div>
```

```js
angular.module('app', [])
.controller('ParentController', ParentController)

function ParentController($scope) {
	var vm = {};
	vm.username = 'My Name';

	$scope.vm = vm;
}
```
{% endelement %}

注意 `vm` 在這裡是可以任意自訂的名稱，取名 `vm` 是 "View Model" 的意思。

#### 指定 "controllerAs" 之後，controller 中的 this 與 $scope 有何不同？

由於上面的作法，可以優雅地解決 scope 遮蔽問題，AngularJS 1.2 針對這個作法，新增了 "controllerAs" 語法。

首先，不推薦，但你可以使用 `ng-controller="MyController as $ctrl"` 的方式啟用這個功能；
再者，你可以在 `.directive()` 及 `.component()` 函數，使用 `controller: 'MyController as $ctrl'` 的方式啟用，或者以 `controllerAs: '$ctrl'` 的方式另外指定。

"ControllerAs" 語法，只是上面介紹的作法的語法蜜糖，當你寫 `controller as $ctrl` 時，AngularJS 在背後所做的事，基本上就跟上面一樣。

細節是這樣的，首先，記住 controller 函數其實是一個 constructor，AngularJS 會以 `new` 操作子呼叫你的 controller 函數，以建立一個新的物件，然後，AngularJS 會自動幫你在 `$scope` 中，以 `$ctrl` 為屬性名稱，將該物件指定給 `$scope`。直接以程式展示的話，大概是像這樣：

```js
function MyController() {
	this.username = 'My Name';
}

function $$RealController$$($scope) {
	$scope.$ctrl = new MyController();
}
```

所以，從另一個角度看，在上面的 controller 中的 `this`，只是一個普通的 JavaScript 物件，當然也就沒有 $scope 的功能。這就解釋了為什麼使用了 "controllerAs" 語法後，就無法在 controller 中使用 $scope 的功能。因此，如果在 controller 中需要 $scope 功能的話，就必須再另外透過 DI 注入 $scope 物件，就像這樣：

```js
MyController.$inject = ['$scope'];
function MyController($scope) {
	this.username = 'My Name';

	$scope.$watch('registered', function (newValue, oldValue) {
		// ...
	});
}
```

#### 參考資料 / 延伸閱讀

這一篇解釋得很詳細：

[AngularJS: "Controller as" or "$scope"?](http://codetunnel.io/angularjs-controller-as-or-scope/)

這一篇說明為何 1.3 需要引進 `bindToController`，以及後來在 1.4 的演進：

[Exploring Angular 1.3: Binding to Directive Controllers](http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html)。

John Papa 是一直大力推廣 "controllerAs" 語法的人：

[Do You Like Your Angular Controllers with or without Sugar?](http://www.johnpapa.net/do-you-like-your-angular-controllers-with-or-without-sugar/)
[AngularJS's Controller As and the vm Variable](http://www.johnpapa.net/angularjss-controller-as-and-the-vm-variable/)

然後，AngularJS 1.5 引進了上面介紹的 `.component()` 函數，同時，似乎是為了有所區別，AngularJS team 決定 (沒有找到相關資料，請看下面的推論) 引入新的 `bindings` 屬性，用來完全取代 `scope` 及 `bindToController`。我想這應該是為了避免使用者誤用，而造成模稜兩可的狀況：

1. 退回到 1.4，強制定義 `scope: {}`，而使用 `bindToController` 定義屬性

	因為在 1.4 時，`bindToController` 屬性就可以直接定義屬性，其意義與 `bindings` 完全相同，只不過並未強制 `scope: {}` 的定義。若這麼做的話，等於是期望使用者這樣定義：

	```js
	{
		scope: {},
		bindToController: {
			attribute: '='
		}
	}
	```

	但是若使用者卻使用 1.3 的語法：

	```js
	{
		scope: {
			attribute: '='
		},
		bindToController: true
	}
	```

	那麼，哪個屬性有效呢？記住，我們已經強制定義 `scope: {}`，所以這裡的 `scope` 定義無效；而我們期望定義為 hash object 的 `bindToController`，在這裡當然也找不到正確的屬性定義。

2. 退回到 1.3，仍然使用 `scope` 定義屬性，強制 `bindToController: true` 屬性。

	也就是說，期望使用者這樣定義：

	```js
	{
		scope: {
			attribute: '='
		},
		bindToController: true
	}
	```

	但是若使用者卻使用 1.4 的功能：

	```js
	{
		scope: {},
		bindToController: {
			attribute: '='
		}
	}
	```

	那麼，又是哪個屬性有效呢？同樣地，我們已經強制定義 `bindToController: true`，所以這裡的 `bindToController` 定義無效；而我們期望定義為 hash object 的 `scope`，在這裡當然也找不到正確的屬性定義。

所以，由此推論，AngularJS team 為了避免上述兩種模稜兩可的狀況，而決定乾脆同時忽略 `scope` 和 `bindToController` 的使用者定義，分別強制其值為 `{}` 及 `true`，而另外使用 `bindings` 來定義屬性。

雖然不確定理由是否如上述推論，但同時有三個屬性 (`scope`, `bindToController`, `bindings`)，提供一樣的功能，顯然又是一個為了向後相容，而疊床架屋的例子，雖然解決了問題，但同時也造成了更多混淆。

### 少用 `$rootScope`

出處：[Limit your use of $rootScope](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#5a49)

應該不須贅言，`$rootScope` 基本上就等於 global。

### 盡量讓狀態靠近使用的元件

出處：[Keep your state as close as possible to the components which need it.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#ce03)

大部分情況下，你的元件應該能自己自足，或者，頂多需要由父元件提供資料。有些時候，你可能需要在多個元件之間共用資料。除非你是在開發通用的元件，譬如 Tab / TabPanel，這時你可能要考慮使用 [`require`](https://toddmotto.com/directive-to-directive-communication-with-require/) 屬性。否則，開發一般應用程式時，應該盡量在最靠近它們的共同父元件上提供共用的資料。

__index.html__
```html
<body ng-app="app">
	<parent></parent>
</body>
```

__parent.js__
```js
var template = [
	'<child-one foo="vm.bar"></child-one>',
	'<child-two baz="vm.bar"></child-two>'
].join('');
app.component('parent', {
	template: template,
	controller: ParentController,
	controllerAs: 'vm'
});

function ParentController() {
	this.bar = 'woo';
}
```

__child-one.js__
```js
app.component('childOne', {
	bindings: {
		foo: '='
	},
	controller: ChildOneController,
	controllerAs: 'vm'
});

function ChildOneController() {
	console.log(this.foo);
}
```

__child-two.js__
```js
app.component('childTwo', {
	bindings: {
		baz: '='
	},
	controller: ChildTwoController,
	controllerAs: 'vm'
});

function ChildTwoController() {
	console.log(this.baz);
}
```

### Forget about services and providers

出處：[Forget about services and providers](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#ca4a)



### Forget about module.config

出處：[Forget about module.config](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#a583)


### Be careful with event publishing and listening

出處：[Be careful with event publishing and listening](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#fb87)

### Take advantage of $exceptionHandler

出處：[Take advantage of $exceptionHandler](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#7461)

### Find a good way to publish logs to the server side

出處：[Find a good way to publish logs to the server side](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#b375)

### Use angular-ui-router

出處：[Use angular-ui-router](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#92ad)

### Be careful with promises and error handling

出處：[Be careful with promises and error handling](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#933e)

### Try to avoid lazy loading

出處：[Try to avoid lazy loading](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#71b6)


### Be careful with the digest cycle

出處：[Be careful with the digest cycle](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#64a1)

## 結論

以上整理，已盡力將參考資料完整列出，惟個人學識有限，如有謬誤或不足之處，歡迎補正，謝謝。
