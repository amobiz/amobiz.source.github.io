title: "AngularJS 1.5 最佳實務"
date: 2016-04-11 03:44:00
comments: true
category:
  - Programming
tags:
  - notes
  - AngularJS
---

## 前言

基於以下三點理由：

* 雖然 AngularJS 2.0 發佈在即 (據說即將於 5 月正式發佈)，但是既有的 AngularJS 1.x 程式碼仍需要維護。
* 由於 AngularJS 1.x 受到廣泛的歡迎，前後做了不少的改進，因此網路上到處可見其實已經過時的作法。
* 另一方面，基於向後相容的原則，有些功能雖然被保留下來，但未必是最佳作法。

『你可以這麼做，不代表你必須這麼做』，基於『JavaScript: The Good Parts』的哲理，本文整理截至目前 AngularJS 1.5 為止， 個人以為的最佳實務做法。

<!-- more -->

本文主要基於 [Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef)
 以及 [Angular 1 Style Guide](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md) 兩篇文章。

### 不要使用 `ng-controller`

出處：[Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout. -- Don’t use ng-controller](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#0b67)

典型的 `ng-controller` 用法如下：

```html
<div ng-controller="myController">
  <strong>{{foo}}</strong>
</div>
```

這裡有什麼問題呢？

* `ng-controller` 違反元件封裝的原則：template 未能與 controller 程式碼封裝在一起，而獨自暴露在 html 中。
* 無法重複使用：基於第一個理由，你的 controller 無法直接重複使用：必須複製 template。

### 不要在路由中指定 controller

出處：[Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout. -- Don’t specify controllers in your routes](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#5b61)

不論是 AngularJS 內建的 router 或是一般常用的 ui-router，典型的寫法，都是同時指定 template/templateUrl 及 controller：

```js
$routeProvider.
  when('/phones', {
    templateUrl: 'partials/phone-list.html',
    controller: 'PhoneListCtrl'
  });
```

這裡有什麼問題呢？其實跟『不要使用 `ng-controller`』的狀況類似，都是與封裝有關：

* 若使用 `template` 來指定，那麼當要重複使用 controller 時，就必須複製該 template，
* 若使用 `templateUrl` 來指定，那麼就有可能不小心指定了錯誤的 template 檔案，造成與 controller 不一致的狀況。

### 使用 component 取代 `ng-controller`

出處：[Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout. -- Make everything a directive](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#e211)

基於上面兩點，應該將需要使用到 `ng-controller` 的部份，一律改用 component 來寫。

雖然還是可以使用 [`$compileProvider.directive()`](https://docs.angularjs.org/api/ng/provider/$compileProvider#directive) 來定義 directive，AngularJS 1.5 提供了新的 [`.component()`](https://docs.angularjs.org/api/ng/provider/$compileProvider#component) 函數：

__myComponent.html__
```html
<strong>{{vm.foo}}</strong>
```

__myComponent.js__
```js
var myTemplate = require('./myComponent.html');

myapp.component('myComponent', {
	bindings: {
		foo: '=",
		oneWayAttr: '<',
		twoWayAttr: '=',
		stringAttr: '@',
		callbackAttr: '&'
	},
	template: myTemplate,
	controller: ['$http', MyComponent],
	controllerAs: 'vm'
});

function MyComponent($http) {
	this.foo = 'bar';
}
```

注意，使用 `.component()` 函數來建立元件時：

* 必然以 `restrict: 'E'` 的形式建立，也就是只能建立 tag 形式的元件，
* 必然以 `scope: {}` 的形式建立，也就是建立 "isolated scope"，不會繼承 parent scope。因此，若需要外部 scope 的資料，必須明確在 `bindings` 中定義屬性，並在使用 tag 時傳入。
* 承上，似乎是為了有所區別，AngularJS team 決定 (沒有找到相關資料，請看後面『永遠使用 "controllerAs" 語法』中的推論) 使用 `bindings` 取代 `scope` 及 `bindToController` 屬性。
* 如果你沒有自行指定 `controllerAs`，則會自動幫你指定為 `$ctrl`，也就是說，強迫必須使用 `controllerAs` 語法 (參考後面『永遠使用 "controllerAs" 語法』)。

另外，

* 由於 `.component()` 函數只能用來建立 tag 元件，如果元件必須同時或者只支援其他類型，譬如 attribute 形式，則必須使用 `.directive()` 函數定義。
* 上面使用 `require()` 引入 template 檔案的作法，是採用 Webpack 的作法。實務上可以直接使用 `templateUrl` 指定外部檔案, 或直接以內聯的形式定義 `template` 內容。
* 將 controller 放在後面獨立定義，並以 constructor 的形式，開頭名稱大寫，是 John Papa [推薦的作法](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#named-vs-anonymous-functions)。

最後，再提醒一下，定義元件時，使用 `myComponent` 名稱，這名稱就稱為該元件的 directive name。首字小寫，這是 AngularJS 定義元件的推薦慣例。(當作是定義 instance 變數，所以小寫開頭。)
而在 html 中使用時，則必須使用 `my-component`，這稱為該元件的 tag name。全部小寫，以 `-` 分隔單字，雖然 HTML 不區分大小寫，但是使用全小寫是推薦的慣例。
而 controller 的名稱為 `MyComponent`，因為它是一個 constructor。首字大寫，表示這是一個 class，這是 JavaScript 的慣例。

一旦定義好 component，就可以如下使用：

__在 markup 中使用__

```html
<body ng-app="myApp">
	<my-component foo="bar"></my-component>
</body>
```

__在路由中使用__

```js
$routeProvider.
  when('/phones', {
    template: '<my-component foo="bar"></my-component>'
  });
```

好處如下：

* 完全封裝，不須再擔心 controller 與 template 不一致，
* 需要的屬性可以由外部以偏好的方式，以 expression 的形式指定，傳入的是計算後的值，元件內部不再依賴於外部的特定屬性名稱，
* 如果需要處理事件，也可以在 `bindings` 中以 `eventName: '&'` 的方式定義，同樣由外部以偏好的方式指定，元件不需要依賴於外部 scope 的特定方法名稱，
* 因為是 "isolated scope"，所以不必擔心 scope 之間的資料存取、覆蓋、同步問題。

[Refactoring Angular Apps to Component Style](http://teropa.info/blog/2015/10/18/refactoring-angular-apps-to-components.html)
這篇文章詳細介紹各種將 controller 改以 component 的形式的步驟，相當值得一讀，強烈推薦。

### 永遠使用 isolated scope

出處：[Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout. -- Always use an isolated scope](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#f77d)

首先，你只有在定義 directive 時，才能指定 scope 種類。而 scope 有三種：

1. isolated scope: `scope: {}`

	建立一個與世隔絕的 scope。

2. new scope: `scope: true`

	建立新的 child scope，並且繼承父 scope。

3. no scope: `scope: false`

	不建立 scope，直接使用父 scope。

既然 directive 就是 tag 和 attribute (還有 class 和 comment 但是不建議使用)，讓它們可以直接存取父元件的資料不是很奇怪嗎？標準 html 的標籤不都是要自行指定屬性？
因此，強烈建議一律使用 "isolated scope"，不要使用另外兩種。當需要外部 scope 資料時，請明確定義屬性，並由外部指定傳入。

### 永遠將要傳遞的資料以物件加以包裝，或使用 "controllerAs" 語法

出處：[Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout. -- Only ever bind to sub-properties of an object](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#838c)、
[Exploring Angular 1.3: Binding to Directive Controllers](http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html)

只要遵循上面『使用 component 取代 `ng-controller`』的原則，即自動 (強制) 獲得使用 "controllerAs" 及 "isolated scope" 的好處。
如果你不需要知道 AngularJS 過去最被詬病的 scope 黑暗歷史，或者，你已經了解什麼是 "controllerAs"，可以放心跳過這一段。

像這樣的寫法：

```html
<input type="text" ng-model="username" />
```

其中 `username` 將直接繫結到上層 scope 的 `username` 屬性。這裡的關鍵字是『上層 scope』。

由於某些 AngularJS 的 directive，譬如 `ngIf` 會建立新的 scope，也就是前面的提到的 "new scope"，注意這會繼承到 parent scope。
意思是說，你的 binding 將會根據你的 tag 所在的位置，因而繼承了你沒有預料到的『上層 scope』，而可能有不同的行為。

其次，由於屬性是以 prototype 的方式繼承，一旦 child scope 建立了同名的屬性，就同時遮蔽了 parent scope 的同名屬性。使得原本希望直接更新 parent scope 屬性的意圖落空。

注意，以下範例為了清楚起見，直接使用 `ng-controller` 建立新的 scope，實務上仍然建議『使用 component 取代 `ng-controller`』。

<p data-height="268" data-theme-id="0" data-slug-hash="NNywWd" data-default-tab="result" data-user="amobiz" class="codepen">See the Pen <a href="http://codepen.io/amobiz/pen/NNywWd/">AngularJS Scope Problem</a> by amobiz (<a href="http://codepen.io/amobiz">@amobiz</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

```html
<div ng-app="app">
	<h4>Form 1</h4>
	<form ng-controller="ParentCtrl">
		<label>Username: </label>{{username}}<br>
		<input type="text" ng-model="username" />
	</form>

	<h4>Form 2</h4>
	<form ng-controller="ParentCtrl">
		<label>Username: </label>{{username}}<br>
		<div ng-if="!registered">
			<input type="text" ng-model="username" />
		</div>
	</form>
</div>
```

```js
angular.module('app', [])
.controller('ParentCtrl', ParentCtrl)

function ParentCtrl($scope) {
	$scope.username = 'My Name';
}
```

注意上面 Form 2，當你輸入資料時，ParentCtrl 的 `username` 並不會同步更新。

為了避開巢狀 scope 的 prototype properties 繼承問題，可以在 parent scope 中以物件的形式將值包裝起來。
這樣，在 child scope 中，只要永遠不直接對 scope 設定屬性，就不用擔心 scope 屬性遮蔽問題。而透過該物件存取其屬性，就能自由與 parent scope 交換存取資料。

<p data-height="268" data-theme-id="0" data-slug-hash="oxEowv" data-default-tab="result" data-user="amobiz" class="codepen">See the Pen <a href="http://codepen.io/amobiz/pen/oxEowv/">AngularJS Scope via Object</a> by amobiz (<a href="http://codepen.io/amobiz">@amobiz</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

```html
<div ng-app="app">
	<h4>Form 1</h4>
	<form ng-controller="ParentCtrl">
		<label>Username: </label>{{vm.username}}<br>
		<input type="text" ng-model="vm.username" />
	</form>

	<h4>Form 2</h4>
	<form ng-controller="ParentCtrl">
		<label>Username: </label>{{vm.username}}<br>
		<div ng-if="!vm.registered">
			<input type="text" ng-model="vm.username" />
		</div>
	</form>
</div>
```

```js
angular.module('app', [])
.controller('ParentCtrl', ParentCtrl)

function ParentCtrl($scope) {
	var vm = {};
	vm.username = 'My Name';

	$scope.vm = vm;
}
```

注意 `vm` 在這裡是可以任意自訂的名稱，取名 `vm` 是 "View Model" 的意思。

#### 指定 "controllerAs" 之後，controller 中的 this 與 $scope 有何不同？

由於上面的作法，可以優雅地解決 scope 遮蔽問題，AngularJS 1.2 針對這個作法，新增了 "controllerAs" 功能。

首先，不推薦，但你可以使用 `ng-controller="MyCtrl as $ctrl"` 的方式啟用這個功能；
再者，你可以在 `.directive()` 及 `.component()` 函數，使用 `controller: 'MyCtrl as $ctrl'` 的方式啟用，或者以 `controllerAs: '$ctrl'` 的方式另外指定。

"Controller as" 語法，只是上面介紹的作法的語法蜜糖，當你寫 `controller as $ctrl` 時，AngularJS 在背後所做的事，基本上就跟上面一樣。
細節是這樣的，首先，記住 Controller 函數其實是一個 constructor，AngularJS 會以 new 操作子呼叫你的 controller 函數，建立一個新的物件，
然後，AngularJS 會自動幫你在 `$scope` 中，以 `$ctrl` 為屬性名稱，將該物件指定給 `$scope`。直接以程式展示的話，大概是像這樣：

```js
function MyCtrl() {
	this.username = 'My Name';
}

function $$RealController$$($scope) {
	$scope.$ctrl = new MyCtrl();
}
```

所以，從另一個角度看，在上面的 controller 中的 `this`，只是一個普通的 JavaScript 物件，當然也就沒有 $scope 的功能。
這就解釋了為什麼使用了 "controllerAs" 語法後，就無法在 controller 中使用 $scope 的功能。
因此，如果在 controller 中需要 $scope 功能的話，就必須再另外透過 DI 注入 $scope 物件，就像這樣：

```js
function MyCtrl($scope) {
	this.username = 'My Name';

	$scope.$watch('registered', function (newValue, oldValue) {
		// ...
	});
}
```

參考資料：

這一篇解釋得很詳細：

[AngularJS: "Controller as" or "$scope"?](http://codetunnel.io/angularjs-controller-as-or-scope/)

這一篇說明為何 1.3 需要引進 `bindTocontroller'，以及後來在 1.4 的演進：

[Exploring Angular 1.3: Binding to Directive Controllers](http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html)。

John Papa 是一直大力推廣 "controllerAs" 語法的人：

[Do You Like Your Angular Controllers with or without Sugar?](http://www.johnpapa.net/do-you-like-your-angular-controllers-with-or-without-sugar/)
[AngularJS's Controller As and the vm Variable](http://www.johnpapa.net/angularjss-controller-as-and-the-vm-variable/)

然後，1.5 引進了上面介紹的 `.component()` 函數，其中又引入新的 `bindings` 屬性，用來完全取代 `scope` 及 `bindTocontroller'。

我想，AngularJS team 引進新的 `bindings` 屬性，應該是為了避免使用者誤用，而造成模稜兩可的狀況：

1. 若強制定義 `scope: {}`，而使用 `bindToController` 定義屬性

	因為在 1.4 時，`bindToController` 屬性就可以直接定義屬性，其意義與 `bindings` 完全相同，只不過並未強制 `scope: {}` 的定義。
	若這麼做的話，也就是說，期望使用者這樣定義：

	```js
	{
		scope: {},
		bindToController: {
			oneWayAttr: '<',
			twoWayAttr: '=',
			stringAttr: '@',
			callbackAttr: '&'
		}
	}
	```

	但是若使用者卻：

	```js
	{
		scope: {
			oneWayAttr: '<',
			twoWayAttr: '=',
			stringAttr: '@',
			callbackAttr: '&'
		},
		bindToController: false
	}
	```

	那麼，哪個屬性有效呢？記住，我們已經強制定義 `scope: {}`，所以這裡的 `scope` 定義無效；而我們期望定義為 hash object 的 `bindToController`，在這裡當然也找不到正確的屬性定義。

2. 仍然使用 `scope` 定義屬性，強制 `bindToController: true` 屬性。

	也就是說，期望使用者這樣定義：

	```js
	{
		scope: {
			oneWayAttr: '<',
			twoWayAttr: '=',
			stringAttr: '@',
			callbackAttr: '&'
		},
		bindToController: true
	}
	```

	但是若使用者卻反過來：

	```js
	{
		scope: true,
		bindToController: {
			oneWayAttr: '<',
			twoWayAttr: '=',
			stringAttr: '@',
			callbackAttr: '&'
		}
	}
	```

	那麼，哪個屬性有效呢？同樣地，我們已經強制定義 `bindToController: true`，所以這裡的 `bindToController` 定義無效；而我們期望定義為 hash object 的 `scope`，在這裡當然也找不到正確的屬性定義。

所以，由此推論，AngularJS team 為了避免上述兩種模稜兩可的狀況，而決定乾脆同時忽略 `scope` 和 `bindToController` 的使用者定義，分別強制其值為 `{}` 及 `true`，而另外使用 `bindings` 來定義屬性。
這又是一個為了向後相容，而疊床架屋，雖然解決了問題，但同時也造成了更多混淆的例子。

#### Component Helper

這是 AngularJS 1.5 新增的功能。

為了讓 AngularJS 1.X 移植到 AngularJS 2.0 比較容易，而提供的比較接近 AngularJS 2.0 component 寫法的方式來定義元件。

```js
var component = {
	bindings: {
		count: '='
	}
};
app.component('componentName', component);
```

推薦像上面這樣，將 `component` 的設定另外定義，這樣比較接近 AngularJS 2.0 定義 component 的方式。

注意：

1. 使用 `component()` 函數時，實際上等於指定 directive 的參數如下:

	```js
	{
		restrict: 'E',
		scope: {}
	}
	```
	因此 `component()` 函數只能用來建立 tag 形式的 directive。其他形式的 directive，仍然必須使用原本的方式建立。
	建議只要是 tag 形式的 directive，都使用 `component()` 函數來建立 (參考下面 Directive Factory 的說明)。

2. 在 Angular 1.2 ~ 1.4 之間引入的 `bindToController`，由於強烈建議應該使用只 isolated scope，因此可被 `bindings` 完全取代，所以我認為不應再使用 `bindToController`。

3. 綜合以上兩點
	1. 撰寫 component / tag directive 時，應該：

		```js
		app.component('myComponent', {
			bindings: {
				value: '@',
				oneWay: '<',
				twoWay: '=',
				callback: '&'
			},
			controller: ['$inject', MyController],
			controllerAs: 'vm'
		});

		function MyController($inject) {
		}
		```

	2. 撰寫 attribute directive 時，應該：

		```js
		app.directive('myDirective', {
			restrict: 'A',
			scope: {
				value: '@',
				oneWay: '<',
				twoWay: '=',
				callback: '&'
			},
			link: function (scope, element, attrs) {
			}
		});
		```

參考資料：

[Exploring the Angular 1.5 .component() method](https://toddmotto.com/exploring-the-angular-1-5-component-method)

#### Directive Factory

要建立自定義的 directive 時，需要呼叫 [`$CompileProvider`](https://docs.angularjs.org/api/ng/provider/$compileProvider) 的 `.directive()` 函數，其定義為： `directive(name, directiveFactory)`。

其中，`directiveFactory` 函數，可以回傳一個 [`definition object`](https://docs.angularjs.org/api/ng/service/$compile#directive-definition-object)，指定相關的屬性設定。用法可參考 [Creating Custom Directives](https://docs.angularjs.org/guide/directive)。

注意 `definition object` 中有兩個進階屬性，`compile` 和 `link` 跟 directive 的處理過程相關。

##### compile 屬性

compile 函數的定義為 `function compile(element, attrs) { ... }`。

注意這裡的 element 是原始的未處裡過的 DOM。`compile` 函數應該負責處理一次性的對 DOM 的操作，並且視需要，回傳一個物件，該物件可以包含 `pre` 和 `post` 兩個函數。類似這樣：

```js
function directiveFactory() {
	return {
		restrict: 'E',
		compile: function (tElem, tAttrs) {
			console.log(name + ': compile');
			return {
				pre: function (scope, iElem, iAttrs) {
					console.log(name + ': pre link');
				},
				post: function (scope, iElem, iAttrs) {
					console.log(name + ': post link');
				}
			}
		}
	}
}
```

##### link 屬性

link 函數的定義為 `function link(scope, element, attrs, controller, transcludeFn) { ... }`。
如果 directive 有定義 `compile` 函數，通常就不會再定義 `link` 函數，而是直接由 `compile` 函數回傳需要的 `pre` 和 `post` 函數。
此 link 函數，相當於 `compile` 函數中回傳的 `post` 函數。

1. 如果有需要，譬如像 `ng-repeat`，Angular (其實就是後面介紹的 `$compile` 函數) 會複製 `compile` 函數處理完的 DOM。
2. 針對每個元件單位，依據需要可能建立對應的 scope，然後呼叫 `link` 函數，進行 scope 和個別 DOM 之間的連結。通常在此 link 函數中對 DOM 註冊必要的 listener。

##### 在 directiveFactory 中回傳 link 函數

另外，還有一種進階作法，是在 `directiveFactory` 函數中回傳一個函數，該函數的作用，相當於上面 `definition object` 中的 `link` 函數、以及 `compile` 函數中回傳的 `post` 函數。
雖然官方不推薦這個作法，但是偶而會看到，所以至少需要了解其原理。

詳細的 directive 處理過程，請參考 [HTML Compiler](#html-compiler) 的說明。

#### HTML Compiler

所有的工作，都是由 `$compile` 函數處理。而其中最重要需要知道的是，Angular 處理的是 DOM，而不是 string template，以維持 DOM 結構的穩定。

1. `$compile` 函數首先找到 `ng-app` directive，然後由此開始，尋找所有的 directive。
2. 依據 directive 的 priority 排序，同一元件中 priority 最大的 directive 最先處理。
3. `$compile` 依照階層以及 priority，逐一處理 directive。過程中，會依照階層關係，往下逐一呼叫每個 directive 的 `compile` 函數 (如果有的話)。此時 directive 的 `compile` 函數可以進行一次性的對 DOM 的操作。
	正規化後的每個 directive 的 `compile` 函數應該回傳 { pre, post } 函數，`$compile` 函數會將整個 DOM 和這些 link 函數，結合為一個統合的 (combined) link 函數，並將之回傳。
4. 在連結階段，將實際處理 scope 與 DOM 的繫結。
	此時將依照階層關係，往下逐一呼叫每個 directive 的 `pre` 函數 (如果有的話)，所以父元件的 pre 會先於子元件被呼叫。
	到達終端後，再以相反順序，呼叫每個 directive 的 `post` 函數 (如果有的話)，因此父元件的 post 會晚於子元件被呼叫。

虛擬碼大約如下：

```js
var $compile = ...; // injected into your code
var scope = ...;
var parent = ...; // DOM element where the compiled template can be appended

var html = '<div ng-bind="exp"></div>';

// Step 1: parse HTML into DOM element
var template = angular.element(html);

// Step 2: compile the template
var linkFn = $compile(template);

// Step 3: link the compiled template with the scope.
var element = linkFn(scope);

// Step 4: Append to DOM (optional)
parent.appendChild(element);
```

參考資料：

[HTML Compiler](https://docs.angularjs.org/guide/compiler)
[AngularJS directives內compile及link的函式本質](https://987.tw/2014/09/03/angularjs-directivesnei-compileji-linkhan-shi-de-ben-zhi/)

#### One-Time data binding

這是 AngularJS 1.3 新增的功能。

參考資料：

[AngularJS: One-Time VS Two-Way Data Binding](http://kodypeterson.com/angularjs-the-3-types-of-data-binding/)

雖然這篇文章說沒有所謂 One-Way data binding，不過後來 AngularJS 1.5 的確推出了 One-Way data binding 的功能。見後述。

[AngularJS one-time binding syntax](https://toddmotto.com/angular-one-time-binding-syntax/)

#### One-Way data binding

這是 AngularJS 1.5 新增的功能。

針對 directive 的 scope binding，可以使用 `<` 指定資料只由 parent scope 傳遞到 child scope。然而由於 object 是參照的關係，child scope 可以設定 parent scope 的 object 的 property，直接更改到 parent scope 的資料。

```js
app.directive('directiveName', function () {
	return {
		scope: {},
		bindToController: {
			count: '<'
		},
		controller: function () {},
		controllerAs: 'vm'
	};
});
```

或使用前面提到的，同樣是 AngularJS 1.5 新增的 `component()` 函數：

```js
var component = {
  bindings: {
		count: '<'
	}
};
app.component('componentName', component);
```

參考資料：

[One-way data-binding in Angular 1.5](https://toddmotto.com/one-way-data-binding-in-angular-1-5/)

[Exploring the Angular 1.5 .component() method](https://toddmotto.com/exploring-the-angular-1-5-component-method/#one-way-bindings)

#### One Time Data Binding with Recompile

若資料很少變動，但是偶而仍有變動可能，則可以考慮利用 `$compile` 重新 compile。

假設

```js
var marked = require('marked');

app.directive('markdown', function ($compile) {
	return function (scope, element, attrs) {
		scope.$watch(function (scope) {
			return scope.$eval(attrs.markdown);
		}, function (value) {
			if (typeof value !== 'undefined') {
				value = marked(content);
				element.html(value);
				$compile(element.contents())(scope);
			}
		};
	};
});
```

幾個重點：

1. 這個 directiveFactory 回傳的是 link 函數，所以 signature 為：`function (scope, element, attrs)`。
2. 由於第一項的緣故，也就是並未定義 `scope` 屬性的緣故，所以在傳入的 scope 中，並不會有任何自定義屬性 (這個例子中為 `markdown`)，所以不能使用 `scope.$watch('markdown', handler)` 來監看資料，
	所以，這裡必須使用 factory method 的方式，透過 `$eval` 處理值的監看： `scope.$watch(function (scope) { return scope.$eval(attrs.markdown); }, handler);`
3. 由於監看函數總是會在第一次的時候，以 `undefined` 值呼叫 handler 函數，為了避免無謂的處理，這裡檢查並排除這種情形。
4. 由於 `$compile` 函數只處理 DOM 元素，因此，在此先將結果設定給元件，元件將字串內容轉為 DOM，然後再透過元件的 `.contents()` 函數取出 DOM，再交給 `$compile` 函數處理。
	或者也可以透過 `angular.element(value)` 轉換為 DOM。
5. `$compile` 函數處理後，回傳 link 函數，我們在此立即呼叫它，並傳入 scope 進行繫結。

在這個例子中，`markdown` directive 的作用類似於 `ng-bind-html`，所以如果資料不會異動，也就是沒有重新 compile 的需求的話，可以在處理完畢後，移除 `$watcher`，以達成 one-time binding 的效果：

```js
var marked = require('marked');

app.directive('markdown', function ($compile) {
	return function (scope, element, attrs) {
		var $watcher = scope.$watch(function (scope) {
			return scope.$eval(attrs.markdown);
		}, function (value) {
			if (typeof value !== 'undefined') {
				value = marked(content);
				element.html(value);
				$compile(element.contents())(scope);
				$watcher();
			}
		};
	};
});
```

`.$watch` 函數回傳的是一個 `$watcher` 函數，當不需要繼續 `$watch` 的時候，只要呼叫該函數，就可以終結該 `$watch`。

如果使用 `definition object` 的形式撰寫，同時定義 `scope` 屬性，則可以直接 `$watch` 需要的屬性。因此，上面的寫法，相當於：

```js
var marked = require('marked');

app.directive('markdown', function ($compile) {
	return {
		restrict: 'A',
		scope: {
			markdown: '<'
		},
		link: function (scope, element, attrs) {
			var $watcher = scope.$watch('markdown', function(value) {
				if (typeof value !== 'undefined') {
					value = marked(value);
					element.html(value);
					$compile(element.contents())(scope);
					$watcher();
				}
			});
		}
	};
```

#### $sanitize

1. 預設在使用 `ng-bind-html` 時，即會自動進行 `$sanitize` 處理，若有需要做進一步的處理，則可以直接呼叫 `$sanitize` 函數。
2. `$sanitize` 會移除不安全的 tag，包括 `script`, `iframe`, `video`, `audio` 等。 `src`, `href` 等屬性也會進行處理。
3. `$sanitize` 會將中文字轉換為 `&#uuuu;` 的形式，將 `\n` 轉換為 `&#10;`。所以在 `$sanitize` 之後，要處理內容時要注意這一點。
4. 即使經過手動 `$sanitize` 處理，若是透過 `ng-bind-html` 來顯示，則還是會再次進行 `$sanitize` 處理。所以，若在 `$sanitize` 處理之後，又另外加了一些被禁用的 tag，則該 tag 仍然會被移除。
	因此，若確信在 `$sanitize` 處理之後的內容是安全的，則可以透過 `$sce.trustAsHtml()` 函數來告知 `ng-bind-html` 不需要再 `$sanitize` 處理。但是這種處理方式有點冗餘，可以參考上面 `markdown` directive 的作法。

```js
function markdown(content) {
	var result = this.$sanitize(content);
	result = marked(result);
	result = this.$sce.trustAsHtml(result);
	return result;
}
```

#### $watch(), $digest(), $apply() 及 $on(), $broadcast() 用途分別為何？

[$watch How the $apply Runs a $digest](http://angular-tips.com/blog/2013/08/watch-how-the-apply-runs-a-digest/)

[理解$watch ，$apply 和 $digest - 理解数据绑定过程](http://www.angularjs.cn/A0a6)

#### Batarang

1. 對於 one time binding 的支援似乎有些問題：

有文章說它會 disable one time binding, 現在一時找不到該文。

我發現 one time binding 的寫法會有影響，
這樣在 Batarang 才不會出現 watcher:

```
{{::item.url}}
```

若這樣:

```
{{ ::item.url }}
```

就會出現 (也就是 one time binding 無效)。但後者似乎是官方推薦的寫法。

2. 似乎不會追蹤手動呼叫的 `$watch()`。

3. 它的 $watch view，不斷地閃動，根本看不清楚 watch text 是什麼，對於排除不必要的 $watch 實在不方便。

#### jqLite

號稱是簡易版的 jQuery，但是由於 API 不支援完整的 jQuery 功能，所以使用時經常踩雷之後才會注意到。譬如：`.children()`, `.parent()` 不支援 selector，`.find()` 雖然支援，但只能使用 tagname。嗯....雖然文件有簡單的註記，但誰會記得這些東西啊～～。這些功能應該 (至少在 development 模式下) 要做 assert，有不支援的參數應該要丟出 exception 才對。


### 文章摘要

#### [WHEN TO USE DIRECTIVES, CONTROLLERS, OR SERVICES IN ANGULAR JS](http://kirkbushell.me/when-to-use-directives-controllers-or-services-in-angular/)

通常在 controller 中，回應 user 的行為，對 model/service 進行操作：

```js
function BookCtrl($scope, Book) {
  $scope.addBook = function () {
    Book.addBook({ title: "Star Wars", author: "George Lucas" });
  };
}
```

```html
<button ng-click="addBook()">Add</button>
```

這篇文章建議將 directive 寫成 attribute，並在 directive 中，直接對 service 進行操作，以避免在不同 view 中，重複撰寫 controller 來處理相同的邏輯。蠻有趣的論點。

```js
module.directive( "addBookButton", [ 'Book', function( Book ) {
  return {
    restrict: "A",
    link: function( scope, element, attrs ) {
      element.bind( "click", function() {
        Book.addBook( { title: "Star Wars", author: "George Lucas" } );
      });
    }
  }
}]);
```

```html
<button add-book-button>Add</button>
```

### [Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef)


## 結論

以上整理，已盡力將參考資料完整列出，惟個人學識有限，如有謬誤或不足之處，歡迎補正，謝謝。
